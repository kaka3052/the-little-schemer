# the-little-schemer
the little schemer

道法自然的好书
上学最宝贵的收获之一是结交学识过人的朋友。自己闷头学得山穷水尽时，高手轻轻一句点拨，眼前便峰回路转，柳暗花明。每次上完课，有幸和朋友小聚，请教弱智问题，听朋友妙语解惑，实在是难得的人生乐事。读The Little Schemer，也有同样的感受。读The Little Schemer的过程，就是被良师引导的过程。

用作者的话说，The Little Schemer是一本教人理解计算本质的书。编程语言Scheme不过是传道的载体。书的体例独特。每页分成两列。每列寥寥几行代码，数段散句。左边一列问个问题。右边一列给出答案。作者就用这种轻松对话的形式讲解递归和函数编程。例如下面的截图。 


这本书最吸引我的地方是它讲解的方式：书里仿佛没有什么难点，也没有长篇讨论。每章都是逐层推进的问题和相应的解答。比如翻看书第一页，就是“atom是不是atom?”。我差点以为买了本缺页的书，下意识的向前翻了一下，看是不是漏掉了开头。 在这些精心设计的例子启发下，我们自然地总结出编程的概念和方法。一切水到渠成。这其实是非常高效的训练，对初学者尤其有用。从现象里归纳出共性、由实践中抽象出模式，在表象下看到本质是解决问题的重要技巧。编程语言也好，公式也好，不过是表达我们思路的手段。何况很多强有力的编程技巧也是前人从无数代码里提炼而来。还有什么比自己体验提炼过程更让人印象深刻的学习手段呢？书不厚。180来页。10章。每章读时都觉得简单，甚至有点琐碎。但书的进度其实毫不含糊。第8章已经引导我们领悟Continuation Passing Style的奥秘。第九章解释了Y-组合子的前世今生，而第十章干脆实现了一个Scheme的解释器。单是第8章就值回书价（本来也不贵。如果连续集The Seasoned Schemer和The Reasoned Schemer一起买，还有折扣）。想象一下，一个对Scheme编程甚至对编程一无所知的新手读完这章后，突然发现CPS函数上挂着的那一大坨累赘事物（黑话所谓的continuation）变得清晰晓畅，已经融入自己的灵魂，是何等爽快的体验。

 

我对书唯一不满的地方是它全用各种食物做数据。鱼子酱，沙门鱼，曲奇什么的满篇都是。个人觉得和家谱树一样无趣。对了，作者没有写任何可以激励读者的内容，比如为什么CPS有用。这也许会打击一部分老大的积极性。

喜欢The Little Schemer的老大们，多半也会喜欢续集The Seasoned Schemer。用序言的话说，The Little Schemer展示了列表是Lisp编程的心脏，而The Seasoned Schemer展示了函数是Lisp编程的灵魂




－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

小S不小
三点

（模仿The little schemer而作）


看官：本人

小S：The little schemer简写

看官：小S，这名字够嗲的。

小S：其实我不小哦，你应该知道我在说什么。

看官（叹气）：你老爸建议认识你不要少于three settings，但我用了thirty settings也没有完全了解你的心，唉。

小S：那当然，老爸不是对你说“study hard and enjoy”了吗。

看官（开始献殷情）：其实一开始看到你，我就知道你和其他不一样。这种对话式的写作手法我只在Plato的对话录里读到过，而想要完全读懂Socrate的语言是多么不容易。而且，后来采用它的科技著作少之又少。伽利略好像也用这种手法写过书，不过他的目的可能是想模糊自己的立场，通过宗教裁判所的检查吧。

小S（撒娇似的）：这我倒不知道。其实老爸选择这种写作方法也是迫不得已，他想让读者自己得出结论。我们知道一般的书都是直接给结论的，但老爸觉得这样剥夺了读者思维的乐趣。

看官：有道理。不过老爸为什么要选你Scheme呢，而不是大多数人用的C/C++，Java之类的，流行的语言？那一行行的括号看的我头都大了。

小S（装大人口气）：看来一定要讲一讲我家的历史了。（清一清嗓子）你认识我的哥哥Lisp吗？

看官：是那个金黄头发的胖胖的帅小伙吗？

小S：Paul Graham叔叔写过一篇“The Roots of Lisp”。其实，爸爸从来都没有想过他会长的这么帅，这么受欢迎。我们家世代都是做科学研究的。爸爸原来也指望他在研究院谋个教职，没想到他在工业界也受欢迎。最妙的是，哥哥本身就是自己数据结构list，所以他能非常方便地自己解释自己。定义7条最基本的函数，而我爷爷McCarthy在最早的论文里用了5条函数，只比欧几里得的几何学公理多1条。所有其他的函数都可以由这些基本函数推导得来。我和哥哥在这一点上几乎是一样的。我们家的格言是“认识你自己”，那是太阳神Apollo的神谕。我的祖先是太阳神的后代。

看官（激动）：是不是那些括号，其实我在开始读你的时候，就有点意识到这一点了。

小S（骄傲）：就是这个，这是我们家的最显著的特征，如果没有那些括号，我和我哥哥就没有魅力了。你看看其他的计算机语言，哪一个本身就是数据结构。他们怎么能和我和我哥哥比，哼。

看官（想笑但没有出声）：他们当然不能和你比。（正色）而且我只在你的身上看到了数学上的美。

小S（神秘）：PG叔叔的文章里讲了我哥哥Lisp和他的解释器，但没有我和我的解释器漂亮。我的哥哥年级大了，垃圾食品吃的多，有点发胖，在家里我们都叫他胖子。但我不一样，我一直在减肥，那些男性杂志还要我去拍封面照呢。我爸爸最喜欢我了。

看官：但是你太难懂了，你...

小S（不耐烦地打断）：我的前7章实际上还是比较简单的，你在DrScheme上coding我就可以了。DrScheme是一个很棒的调试环境。第8章讲的是如何在recursion时同时collect more than one value at a time，也就是continuation。第9章是Turing停机证明和Y combinator的推导，Y combinator是实现recursion的方式。第10章是关于我的一个最简单的解释器，不过我卖了个关子，没有告诉你define怎么写，而且也没有把数据和函数分离，你可以自己想想。你在这3章上花的时间可能比前7章都要多。

看官：不错，我从来没有想过能去研究一下计算机语言的解释器。你知道我是做硬件的，比较底层的东西。恩，Scheme的data和function好像是用一个environment的吧 。

小S（脸红了）：我的解释器大概是所有计算机语言里最简单的了，所以你知道能完全理解我，离认识我的姐姐大S“the seasoned schemer”也不远了。我爸爸觉得读懂她，就能入nature of computing的大门了。

看官：我家隔壁开了一家山东煎饼店，一整张饼只要不到10块钱，又脆又香，老板的小女儿也很cute。我们一起去吧。

小S：恩，放松一下。

另一篇，时间的女儿，http://www.douban.com/note/224590945/


－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

时间的女儿
　　
　　三点
　　
　　我想，SICP是The Little Schemer（TLS）之后，一个不错的选择。TLS关注于Scheme最美的那个部分，而且在读者感到厌倦之前就结束了。相比之下，SICP要直到4.1章才讲Scheme解释器。我读TLS觉得有点味道了，并且能把TLS的程序调通，才决心去写写SICP上的code。如果让我一上来就读SICP，也许也会不知所云，不知道重点在哪里。
　　
　　SICP对读者的要求很高。比如，第一章可以称为“如何用Scheme解数学题”。而且这些数学也不简单，数值分析，数论，微积分，矩阵，信号分析等等，虽然说都是这些学科的初步知识，但对于想学Scheme但没有背景知识的读者来说有相当大的难度。理工科大学生要花四年时间在这些数学问题上，而且等他们毕业以后，能够记住，理解和真正应用的内容，可能还没有SICP里提到的多。如果让我在大学时，做SICP的题目，估计大部分都做不了，也看不懂。
　　
　　假设大多数读者从第一章开始读，线性地往下读，而且还要做些题目，平均阅读长度是多少，我很怀疑。我现在读到3.3章，几乎作了每道题（有170道了），开始觉得力不从心了。FP本身的难度要比C/C++语言编程难得多，尤其是那些higher function，虽然看起来漂亮的很，但要仔细想的话，简直是一些要人绞尽脑汁的技巧。你再去看看公司里的那些代码，要多dirty有多dirty，也没有人说不好，唉。
　　
　　 * * *
　　
　　顺便谈谈对Lisp/Scheme的感觉。
　　
　　我的第一感觉是，这一类语言必死无疑，它们和C语言这一类语言简直是两个极端。C语言是基于机器设计的，所以有大量诸如pointer，memory management的东西，可以说是dirty的很（也可以说hackable的很），把硬件底层的细节大多暴露给了用户。而Lisp是基于McCarthy的数学模型设计的，所以抽象的很，最怪的是把所有的函数都写成(f x y z ...)的形式，在这一点上倒是和汇编语言有点像。
　　
　　在这个Object-Oriented横行的年代，Functional Programming除了在传说中的多核（或者hardware level multi-threading）上有一点优势，还有symbol program和晦涩的call/cc和越来越不好用的macro，还有什么？这仅有的一些优势也会被FP天生的编程困难所抵消。在我熟悉的硬件语言领域（Hardware language），也有语言竞争的现象，结论是像/C++/Java的语言胜出，他们不一定多好，只是工程师熟悉这种模式罢了。绝大多数工程师是随大流的，所有功成名就的老板都是随大流的。再举一个熟悉的例子，Matlab和C比较像，而Mathmatica和Lisp几乎同宗，最后也是Matlab占领了大多数的工程市场，这个市场可要比学术界大许多。
　　
　　Scheme的用户应该都在大学里，而且可能只在Boston附近的那几个大学里，出了学校还有用户吗？谁会自讨没趣到用递归形式或者诸如map之类higher function的写循环？谁会用一个竟然没有name space的语言开发大型程序？谁会看一些满是学术用语，诸如lambda，continuation等晦涩关键词的程序？习惯了用满篇=赋值，能容忍没有这些好东西吗（Scheme有let，set!之类的东西，但远没有=好用）？Scheme的命运令人担忧，虽然有学术界的支持，但没有广大的群众基础。广大的开发人员需要的是“Dirty and Quick”的开发语言，有足够的，简单易懂的库，拿来就能用，他们才没有闲暇来欣赏什么“Beautiful Code”，“Elegent Language”，明天就是deadline，老板的脸色重要，还是代码漂亮重要，不言而喻。
　　
　　 * * *
　　
　　在Lisp大家族里，最有影响力的，也许不是Common Lisp，也不是Scheme，而是Elisp（Emacs Lisp），从用户群就可以看出来。我认识的许多和计算机打交道的朋友都会用Emacs，它上手也比vi简单。我原来用vi，现在用Emacs的vi mode。看看Emacs的配置文件，不知不觉中，就会学到一些Lisp的语法，如果本来懂一些编程知识，那就更没有问题了。
　　
　　事实表明，Emacs用户比VI用户更知道如何扩展editor，对它的原理也理解的更清楚（不包括redisplay之类的复杂算法）。在许多人的印象中，Emacs就像就像它的作者Richard Stallman（RMS，计算机名人堂中的重量级人物，许多hacker心目中的英雄）一样白发苍苍。我在用VIM的时候，也对Emacs不屑一顾。它甚至没有所有“现代流行”的editor都有的tab和dialog，GUI看起来像是70，80年代的老古董。但当我通过TLS和SICP熟悉Lisp这一类语言之后，我才开始阅读扩展Emacs，体会它的设计优点（当然，也许RMS在设计时并没有考虑这些）。举一个简单的例子，大多数的editor都会用one buffer one tab的模式，也就是每开一个文件，就对应一个buffer和tab。但当你开了超过20乃至30，40个文件之后，tab就开始失去它的作用了，也就是想要从tab来选择一个文件变得很困难。而Emacs有一些extension使得这种选择变得十分方便。
　　
　　Emacs和SICP一样，对初学者来说相当困难，并引起初学者的反感。具有讽刺意味的是，这种困难来源作者的一片好意，作者试图将整个系统透明化，告诉用户每一个Key Binding对应那个function，每一个mode对应了那些function re-binding，以及每一个function的实现细节和文档。这对于有经验的工程师是一笔巨大的财富（Emacs包含了上千个function和超过百万行Elisp代码，以及每个function包含的docstring），但对于初学者和熟悉商用IDE环境的用户，却是头痛的。对于习惯于被束缚在一种开发环境下的用户，透明，自由，灵活，反而无法习惯了（虽然我现在在伟大的WinXP下写这篇文章，但我还是要说，这些也是Microsoft这位Big Brother给我们带来副产品）。正是这些特点，使得工程师可以在Emacs下开发org-mode，gud，email/news client，而用vim的script（vim scirpt与elisp相比，可以说是10岁和30岁的差距），几乎完全可以肯定无法实现这些extension。
　　
　　世界上，采用Lisp和承认采用Lisp的公司不多。如Paul Graham所说，前者和后者不同。其一，大多数用户和股东只知道popular language，如果让他们知道公司竟然用不popular的language开发项目，一定会引起恐慌。其二，项目经理怕招不到Lisp programmer接班，他的恐惧是对的。其三，公司将Lisp作为秘密武器，放烟雾弹，让对手用popular language，自己悄悄用Lisp开发。
　　
　　所以，也许读过SICP，写过Scheme程序之后，再也没有机会在项目中写Lisp程序。项目所用的语言是由许多因素共同决定的，主要因素是随大流。然而，无法用自己喜欢并且投入大量精力学习的语言写程序，是一件令人遗憾的事。所以也许，能够更好地理解和使用Emacs才是学习SICP和Lisp的（可能是唯一的，不包括Autodesk用户）最实际的目的。
　　
　　
　　 * * *
　　
　　让我们回到1989年，那时Lisp工作站渐渐被PC取代，各种以写Lisp系统为生的公司不得不写起了C++系统。Gabriel（McCarthy的弟子，在Parallel Lisp方面有贡献）在自己创办的公司里与员工们闲聊时，哀叹“Worse is better”（其实他是想说Simpler is better，或者dirty and quick is better）。这句戏言预言了之后二十年Lisp的宿命，一方面，各种新语言从Lisp吸取养分，另一方面，Lisp本身的用户数量却激剧缩小。人们逐渐把Lisp称为计算机语言里的拉丁语，连许多学校在开发项目时也放弃用Lisp。大家都有一个疑问，Lisp这么强大，为什么没人用？就好像问，“这个女孩这么美，为什么没男朋友”，或者“战争与和平这么好，为什么没人读”一样。这样的问题没法回答。英谚云，真相是时间的女儿（Truth is the daughter of time）。究竟“Better is worse”还是“Better is better”？还要时间来作出评价。
　　
　　 * * *
　　
　　推荐SICP的编程环境：DrScheme（现为DrRacket），choose language -> R5RS，或者在文件头上注明(require r5rs)，这是因为新版的set-car!，set-cdr!被标记为obsolete了，而且要用特殊的数据结构。
　　
　　 * * *
　　
　　（仓促间写成，还不完整，等有了进一步的想法，再加上。标题取自铁伊的一本小说）
　　
　　另一篇，小S不小，http://www.douban.com/review/2215327/
　　SICP 解答 http://code.google.com/p/sicp-exercise/ 