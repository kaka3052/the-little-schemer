
(define subst*
    (lambda (new old l)
        (cond
            ((null ? l) (quote()))
            (else
                (cond
                    ((atom? (car l)) 
                        (cond
                            ((eq? old (car l)) (cons new (subst* new old (cdr l) )))
                            (else (cons old (subst* new old (cdr l))))
                        )
                    )
                    (else (cons (subst* new old (car l)) (subst* new old (cdr l))))
                )
            )
        )

    )
)

(define insertL*
    (lambda (new old l)
        (cond 
            ( (null? l) (quote()))
            (else
                (cond
                    ((atom? (car l))
                        (cond
                            ((eq? old (car l)) (cons new (cons old (insertL* new old (cdr l)))))
                            (else (cons (car l) (insertL* new old (cdr l))))
                        )
                    )
                    (else (cons (insertL* new old (car l)) (insertL* new old (cdr l))))
                )
            )
        )
    )
)


// (member* a l)    p87
// 在这里 a 是chips l为((potato)(chips((www) fish)(chips)))   
// 结果：#t 
(define member*
    (lambda (a l)
        (cond
            ((null ? l) (quote()))
            ((atom? (car l))
                (or (eq? a (car l)) (member* a (cdr l)))
            )
            (else (or (member* a (car l)) (member* a (cdr l))))
        )
    )
)

// 2018-12-6 
//(leftmost l)
// (((hot)(tuna(and))))
// 结果是hot
(define leftmost
    (lambda (l)
        (cond 
            ((atom? (car l)) (car l)
            (else (leftmost (car l)))
        )
    )
)

//(eqlist? l1 l2)
//用eqan?来写eqlist?
(define eqlist?
    (lambda (l1 l2)
        (cond 
            (and (null? l1) (null? l2) #t)
            (or ((null? l1) (null? l2) #f)
            (and (atom? (car l1)) (atom? (car l2)) 
            //典型部分
                (cond
                    ((eqan? (car l1) (car l2)) (eqlist? (cdr l1)(cdr l2)))
                    (else #f)
                )
            )
            (or (atom? car l1) (atom? car l2) #f)
            (else 
                (and (eqlist? (car l1) (car l2)) (eqlist? (cdr l1) (cdr l2)))
            )
    )
)

/*
tips:
WHAT? 每个参数的可能性是以下情况之一：
    1.为空
    2.原子+列表
    3.列表+列表
抽象的本质：
    1.null表示无意义的事情
    2.原子表示当前事情可以下手做
    3.列表表示当前事情还可以拆分，还是复杂。
WHY？为什么这么拆？
    因为、是依赖第一个动作，第一个动作也就意味着当下的时刻or或者说今天。
    所以、第一个动作，即，典型部分。
    由于、典型部分是比自然部分更加重要，对于整体函数的定义来说。
    所以、当下比全部的未来还要重要，因为当下才是本质上定义着你的人生是什么样子的“算法”。
HOW？有什么指导意义？
    1.觉知当下时刻的事情，是三类分支中的哪类事情？
    2.如果是null，则尽量避免，甚至放弃。（无意义之事）
    3.如果是原子，则集中全部注意力，做好。（有意义，且可操作的事）
    4.如果是列表，则拆分。不要一上来就做。（有意义，且不易操作的事）
    5.总结、关键point是：识别出是原子还是列表，因为这俩容易混淆。（都是有意义的事）
SO，最终指导框架是什么？
    1.如果是原子，则一下是一下的做。
    2.如果是列表，则拆解为第一步（典型部分），和其余部分（自然部分）。
*/








